using System;
using System.Collections.Generic;
using APIBlox.AspNetCore;
using APIBlox.AspNetCore.ActionResults;
using APIBlox.AspNetCore.Contracts;
using APIBlox.AspNetCore.Extensions;
using APIBlox.AspNetCore.Filters;
using APIBlox.AspNetCore.ModelBinders;
using APIBlox.NetCore.Extensions;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.ApplicationModels;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json.Serialization;

// ReSharper disable once CheckNamespace
namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    ///     Class MvcBuilderExtensions.
    /// </summary>
    public static class MvcBuilderExtensionsAspNetCore
    {
        private static PaginationMetadataBuilder _pmb;

        /// <summary>
        ///     Adds a binder to allow the <see cref="IQuery" /> filters the ability
        ///     to accept alternate names.  IE: Filter=$Filter=Where, etc.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddFromQueryWithAlternateNamesBinder(this IMvcCoreBuilder builder)
        {
            builder.Services.Configure<MvcOptions>(o => o.ModelBinderProviders.Insert(
                    0,
                    new FromQueryWithAlternateNamesBinderProvider()
                )
            );

            return builder;
        }

        /// <summary>
        ///     Adds a binder to allow the <see cref="IQuery" /> filters the ability
        ///     to accept alternate names.  IE: Filter=$Filter=Where, etc.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddFromQueryWithAlternateNamesBinder(this IMvcBuilder builder)
        {
            builder.Services.Configure<MvcOptions>(o => o.ModelBinderProviders.Insert(
                    0,
                    new FromQueryWithAlternateNamesBinderProvider()
                )
            );

            return builder;
        }

        /// <summary>
        ///     Will make sure that
        ///     <see cref="MvcJsonOptions.SerializerSettings" />.ContractResolver is
        ///     set to use <see cref="CamelCasePropertyNamesContractResolver" />
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddCamelCaseResultsOptions(this IMvcCoreBuilder builder)
        {
            CamelCaseResultsCommon(builder.Services);

            return builder;
        }

        /// <summary>
        ///     Will make sure that
        ///     <see cref="MvcJsonOptions.SerializerSettings" />.ContractResolver is
        ///     set to use <see cref="CamelCasePropertyNamesContractResolver" />
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddCamelCaseResultsOptions(this IMvcBuilder builder)
        {
            CamelCaseResultsCommon(builder.Services);

            return builder;
        }

        /// <summary>
        ///     Adds an MVC convention that requires DI.
        /// </summary>
        /// <typeparam name="TConvention">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="setupAction"></param>
        /// <returns>IMvcCoreBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcCoreBuilder AddConvention<TConvention>(
            this IMvcCoreBuilder builder,
            Action<MvcOptions, TConvention> setupAction = null
        )
            where TConvention : class, IApplicationModelConvention
        {
            builder.Services.AddDependencyWithOptions(setupAction ?? ((o, c) => o.Conventions.TryAdd(c)));

            return builder;
        }

        /// <summary>
        ///     Adds an MVC convention that requires DI.
        /// </summary>
        /// <typeparam name="TConvention">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="setupAction"></param>
        /// <returns>IMvcBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcBuilder AddConvention<TConvention>(
            this IMvcBuilder builder,
            Action<MvcOptions, TConvention> setupAction = null
        )
            where TConvention : class, IApplicationModelConvention
        {
            builder.Services.AddDependencyWithOptions(setupAction ?? ((o, c) => o.Conventions.TryAdd(c)));

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a specific structure,
        ///     IE: {
        ///     data:{ value } | data:[{ value }],
        ///     pagination:{
        ///     totalCount:number,
        ///     nextPage:number,
        ///     previousPage:number
        ///     }
        ///     }
        ///     <para>Works independently of <see cref="EnsureResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="onlyQueryActions">if set to <c>true</c> [only query actions].</param>
        /// <param name="defaultPageSize">Default size of the page.</param>
        /// <param name="defineResponseFunc">The define response function.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddEnsurePaginationResultActionFilter(
            this IMvcCoreBuilder builder,
            ILoggerFactory loggerFactory,
            bool onlyQueryActions = true,
            int defaultPageSize = 1000,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            PaginationCommon(builder.Services, loggerFactory, onlyQueryActions, defaultPageSize, defineResponseFunc);

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a specific structure,
        ///     IE: {
        ///     data:{ value } | data:[{ value }],
        ///     pagination:{
        ///     totalCount:number,
        ///     nextPage:number,
        ///     previousPage:number
        ///     }
        ///     }
        ///     <para>Works independently of <see cref="EnsureResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="onlyQueryActions">if set to <c>true</c> [only query actions].</param>
        /// <param name="defaultPageSize">Default size of the page.</param>
        /// <param name="defineResponseFunc">The define response function.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddEnsurePaginationResultActionFilter(
            this IMvcBuilder builder,
            ILoggerFactory loggerFactory,
            bool onlyQueryActions = true,
            int defaultPageSize = 1000,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            PaginationCommon(builder.Services, loggerFactory, onlyQueryActions, defaultPageSize, defineResponseFunc);

            return builder;
        }

        /// <summary>
        ///     Adds a path and max result size configuration for the Pagination result action filter.
        /// </summary>
        /// <param name="services">The services.</param>
        /// <param name="path">The path.</param>
        /// <param name="maxPageSize">Maximum size of the page.</param>
        /// <returns>IServiceCollection.</returns>
        /// <exception cref="ArgumentException">
        ///     Must not be an empty path. - path
        ///     or
        ///     Must be greater than zero. - maxPageSize
        /// </exception>
        public static IServiceCollection AddPaginationResultMaxPageSizeForPath(this IServiceCollection services, string path, int maxPageSize)
        {
            AddPaginationResultPathToMetadataBuilder(path, maxPageSize);

            return services;
        }

        /// <summary>
        ///     Adds a path and max result size configuration for the Pagination result action filter.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="path">The path.</param>
        /// <param name="maxPageSize">Maximum size of the page.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        /// <exception cref="ArgumentException">
        ///     Must not be an empty path. - path
        ///     or
        ///     Must be greater than zero. - maxPageSize
        /// </exception>
        public static IMvcCoreBuilder AddPaginationResultMaxPageSizeForPath(this IMvcCoreBuilder builder, string path, int maxPageSize)
        {
            AddPaginationResultPathToMetadataBuilder(path, maxPageSize);

            return builder;
        }

        /// <summary>
        ///     Adds a path and max result size configuration for the Pagination result action filter.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="path">The path.</param>
        /// <param name="maxPageSize">Maximum size of the page.</param>
        /// <returns>IMvcBuilder.</returns>
        /// <exception cref="ArgumentException">
        ///     Must not be an empty path. - path
        ///     or
        ///     Must be greater than zero. - maxPageSize
        /// </exception>
        public static IMvcBuilder AddPaginationResultMaxPageSizeForPath(this IMvcBuilder builder, string path, int maxPageSize)
        {
            AddPaginationResultPathToMetadataBuilder(path, maxPageSize);

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a structure, defined by you in the callback.
        ///     Defaults to: {
        ///     data:{ value } | data:[{ value }]
        ///     }
        ///     <para>Works independently of <see cref="EnsurePaginationResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="onlyQueryActions">if set to <c>true</c> [only query actions].</param>
        /// <param name="defineResponseFunc">The define response function.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddEnsureResponseResultActionFilter(
            this IMvcCoreBuilder builder,
            ILoggerFactory loggerFactory,
            bool onlyQueryActions = true,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            builder.Services.Configure<MvcOptions>(o =>
                {
                    FindExistingResultActionFilterAndThrow(o.Filters, nameof(EnsureResponseResultActionFilter));
                    o.Filters.TryAdd(new EnsureResponseResultActionFilter(loggerFactory, onlyQueryActions, defineResponseFunc));
                }
            );

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a structure, defined by you in the callback.
        ///     Defaults to: {
        ///     data:{ value } | data:[{ value }]
        ///     }
        ///     <para>Works independently of <see cref="EnsurePaginationResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="onlyQueryActions">if set to <c>true</c> [only query actions].</param>
        /// <param name="defineResponseFunc">The define response function.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddEnsureResponseResultActionFilter(
            this IMvcBuilder builder,
            ILoggerFactory loggerFactory,
            bool onlyQueryActions = true,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            builder.Services.Configure<MvcOptions>(o =>
                {
                    FindExistingResultActionFilterAndThrow(o.Filters, nameof(EnsureResponseResultActionFilter));
                    o.Filters.TryAdd(new EnsureResponseResultActionFilter(loggerFactory, onlyQueryActions, defineResponseFunc));
                }
            );

            return builder;
        }

        /// <summary>
        ///     Adds the e tag action filter.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="maxAgeSeconds">The maximum age seconds.</param>
        /// <param name="sharedMaxAgeSeconds">The shared maximum age seconds.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcCoreBuilder AddETagActionFilter(this IMvcCoreBuilder builder,
            ILoggerFactory loggerFactory, int maxAgeSeconds = 600, int sharedMaxAgeSeconds = 84600
        )
        {
            builder.AddFilter<ETagActionFilter>(o => { o.Filters.TryAdd(new ETagActionFilter(loggerFactory, maxAgeSeconds, sharedMaxAgeSeconds)); });

            return builder;
        }

        /// <summary>
        ///     Adds the e tag action filter.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="loggerFactory">The logger factory.</param>
        /// <param name="maxAgeSeconds">The maximum age seconds.</param>
        /// <param name="sharedMaxAgeSeconds">The shared maximum age seconds.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddETagActionFilter(this IMvcBuilder builder,
            ILoggerFactory loggerFactory, int maxAgeSeconds = 600, int sharedMaxAgeSeconds = 84600
        )
        {
            builder.AddFilter<ETagActionFilter>(o => { o.Filters.TryAdd(new ETagActionFilter(loggerFactory, maxAgeSeconds, sharedMaxAgeSeconds)); });

            return builder;
        }

        /// <summary>
        ///     Adds an MVC filter with optional setup.
        /// </summary>
        /// <typeparam name="TFilter">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="setupAction"></param>
        /// <param name="order">Filter order</param>
        /// <returns>IMvcCoreBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcCoreBuilder AddFilter<TFilter>(
            this IMvcCoreBuilder builder,
            Action<MvcOptions> setupAction = null,
            int? order = null
        )
            where TFilter : class, IFilterMetadata
        {
            builder.Services.Configure(setupAction ?? (o => o.Filters.TryAdd<TFilter>(order)));

            return builder;
        }

        /// <summary>
        ///     Adds an MVC filter with optional setup.
        /// </summary>
        /// <typeparam name="TFilter">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="setupAction"></param>
        /// <param name="order">Filter order</param>
        /// <returns>IMvcBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcBuilder AddFilter<TFilter>(
            this IMvcBuilder builder,
            Action<MvcOptions> setupAction = null,
            int? order = null
        )
            where TFilter : class, IFilterMetadata
        {
            builder.Services.Configure(setupAction ?? (o => o.Filters.TryAdd<TFilter>(order)));

            return builder;
        }

        /// <summary>
        ///     This filter will prevent errors from being logged when actions have been cancelled.
        ///     If Exception is an OperationCanceledException it is handled otherwise disregarded.
        ///     <para>
        ///         Note that when using fiddler (or maybe other proxies) and when using IISExpress (at this time)
        ///         HttpContext.RequestAborted.IsCancellationRequested is ALWAYS false.
        ///         In other words, this filter won't do a damn thing.
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddOperationCancelledExceptionFilter(this IMvcCoreBuilder builder)
        {
            builder.AddFilter<OperationCanceledExceptionFilter>(order: 0);

            return builder;
        }

        /// <summary>
        ///     This filter will prevent errors from being logged when actions have been cancelled.
        ///     If Exception is an OperationCanceledException it is handled otherwise disregarded.
        ///     <para>
        ///         Note that when using fiddler (or maybe other proxies) and when using IISExpress (at this time)
        ///         HttpContext.RequestAborted.IsCancellationRequested is ALWAYS false.
        ///         In other words, this filter won't do a damn thing.
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcBuilder</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddOperationCancelledExceptionFilter(this IMvcBuilder builder)
        {
            builder.AddFilter<OperationCanceledExceptionFilter>(order: 0);

            return builder;
        }

        /// <summary>
        ///     I MUST be added  after any and all APIBlox features in the builder chain.
        ///     <para>
        ///         DID YOU READ THE ABOVE?!
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="configuration">The configuration.</param>
        /// <param name="env">The env.</param>
        /// <param name="configSection">Configuration section</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddRouteTokensConvention(
            this IMvcCoreBuilder builder,
            IConfiguration configuration, IHostingEnvironment env,
            string configSection = "RouteTokenOptions"
        )
        {
            builder.Services.Configure<MvcOptions>(o =>
                o.Conventions.Add(new RouteTokensConvention(CommonRouteTokens(configuration, env, configSection)))
            );

            return builder;
        }

        /// <summary>
        ///     I MUST be added  after any and all APIBlox features in the builder chain.
        ///     <para>
        ///         DID YOU READ THE ABOVE?!
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="configuration">The configuration.</param>
        /// <param name="env">The env.</param>
        /// <param name="configSection">Configuration section in the form of string dictionary.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddRouteTokensConvention(
            this IMvcBuilder builder,
            IConfiguration configuration, IHostingEnvironment env,
            string configSection = "RouteTokenOptions"
        )
        {
            builder.Services.Configure<MvcOptions>(o =>
                o.Conventions.Add(new RouteTokensConvention(CommonRouteTokens(configuration, env, configSection)))
            );

            return builder;
        }

        /// <summary>
        ///     Adds RFC 7807 Problem Details for HTTP APIs support.  We are using our <see cref="ValidateResourceActionFilter" />
        ///     which in turn will generate a <see cref="ValidationFailureResult" />
        ///     <para>Note this requires that <see cref="ApiBehaviorOptions.SuppressModelStateInvalidFilter" /> be true.</para>
        /// </summary>
        /// <seealso cref="ValidateResourceActionFilter" />
        /// <param name="builder">IMvcCoreBuilder.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddValidateResourceActionFilter(this IMvcCoreBuilder builder)
        {
            builder.Services.Configure<ApiBehaviorOptions>(o =>
                {
                    o.SuppressUseValidationProblemDetailsForInvalidModelStateResponses = true;
                    o.SuppressModelStateInvalidFilter = true;
                }
            );

            return builder.AddFilter<ValidateResourceActionFilter>(order: 0);
        }

        /// <summary>
        ///     Adds RFC 7807 Problem Details for HTTP APIs support.  We are using our <see cref="ValidateResourceActionFilter" />
        ///     which in turn will generate a <see cref="ValidationFailureResult" />
        ///     <para>Note this requires that <see cref="ApiBehaviorOptions.SuppressModelStateInvalidFilter" /> be true.</para>
        /// </summary>
        /// <seealso cref="ValidateResourceActionFilter" />
        /// <param name="builder">IMvcBuilder.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddValidateResourceActionFilter(this IMvcBuilder builder)
        {
            builder.Services.Configure<ApiBehaviorOptions>(o =>
                {
                    o.SuppressUseValidationProblemDetailsForInvalidModelStateResponses = true;
                    o.SuppressModelStateInvalidFilter = true;
                }
            );

            return builder.AddFilter<ValidateResourceActionFilter>(order: 0);
        }

        private static void AddPaginationResultPathToMetadataBuilder(string path, int maxPageSize)
        {
            var pmb = GetPaginationMetadataBuilder();

            if (path.IsEmptyNullOrWhiteSpace())
                throw new ArgumentException("Must not be an empty path.", nameof(path));

            if (maxPageSize <= 0)
                throw new ArgumentException("Must be greater than zero.", nameof(maxPageSize));

            var p = $"{(path.StartsWith("/") ? "" : "/")}{path.ToLowerInvariant()}";

            pmb.RoutePageSizes.Add(p, maxPageSize);
        }

        private static void PaginationCommon(IServiceCollection services, ILoggerFactory loggerFactory, bool onlyQueryActions,
            int defaultPageSize = 100, Func<object, dynamic> defineResponseFunc = null
        )
        {
            services.Configure<MvcOptions>(o =>
                {
                    FindExistingResultActionFilterAndThrow(o.Filters,
                        nameof(EnsurePaginationResponseResultActionFilter)
                    );
                    o.Filters.TryAdd(new EnsurePaginationResponseResultActionFilter(
                            loggerFactory,
                            GetPaginationMetadataBuilder(defaultPageSize),
                            onlyQueryActions,
                            defineResponseFunc
                        )
                    );
                }
            );
        }

        private static IPaginationMetadataBuilder GetPaginationMetadataBuilder(int defaultPageSize = 100)
        {
            _pmb ??= new PaginationMetadataBuilder(defaultPageSize);

            return _pmb;
        }

        private static Dictionary<string, string> CommonRouteTokens(IConfiguration configuration, IHostingEnvironment env, string configSection)
        {
            var ret = configuration.GetSection(configSection).Get<Dictionary<string, string>>();

            if (ret is null)
                throw new ArgumentException(
                    $"In order to use the {nameof(RouteTokensConvention)} you " +
                    $"will need to have an {configSection} configuration entry with key value pairs."
                );

            var hasEnv = ret.ContainsKey("Environment")
                         || ret.ContainsKey("environment");

            if (!hasEnv)
                ret.Add("environment", env.EnvironmentName.ToCamelCase());

            return ret;
        }

        private static void CamelCaseResultsCommon(IServiceCollection services)
        {
            services.Configure<MvcJsonOptions>(s =>
                {
                    if (!(s.SerializerSettings.ContractResolver is CamelCasePropertyNamesContractResolver))
                        s.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
                }
            );
        }

        private static void FindExistingResultActionFilterAndThrow(FilterCollection filters, string who)
        {
            foreach (var objFilter in filters)
            {
                if (!(objFilter is TypeFilterAttribute attr))
                    continue;

                if (!attr.ImplementationType.IsAssignableTo(typeof(EnsureResponseResultActionFilter)))
                    continue;

                throw new ArgumentException(
                    $"You have already added an {attr.ImplementationType.Name}, the {who} can not be used."
                );
            }
        }
    }
}
