using System;
using System.Collections.Generic;
using APIBlox.AspNetCore;
using APIBlox.AspNetCore.ActionResults;
using APIBlox.AspNetCore.Attributes;
using APIBlox.AspNetCore.Contracts;
using APIBlox.AspNetCore.Extensions;
using APIBlox.AspNetCore.Filters;
using APIBlox.NetCore.Extensions;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.ApplicationModels;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json.Serialization;

// ReSharper disable once CheckNamespace
namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    ///     Class MvcBuilderExtensions.
    /// </summary>
    public static class MvcBuilderExtensionsAspNetCore
    {
        ///// <summary>
        /////     Adds the MVC consumes produces json resource result filters for application/json" and
        /////     "application/json-patch+json.  In addition will make sure that
        /////     <see cref="MvcJsonOptions.SerializerSettings" />.ContractResolver is
        /////     set to use <see cref="CamelCasePropertyNamesContractResolver" />
        /////     <para>
        /////         I should be called as early as possible in the configure services chain.
        /////     </para>
        ///// </summary>
        ///// <param name="builder">IMvcCoreBuilder</param>
        ///// <returns>IMvcCoreBuilder.</returns>
        //[Obsolete("Not strictly needed since 2.2, will be removed later.", true)]
        //public static IMvcCoreBuilder AddConsumesProducesJsonResourceResultFilters(this IMvcCoreBuilder builder)
        //{
        //    ConsumesProducesCommon(builder.Services);
        //    builder.AddJsonFormatters().AddDataAnnotations();

        //    return builder;
        //}

        /// <summary>
        ///   Will make sure that
        ///     <see cref="MvcJsonOptions.SerializerSettings" />.ContractResolver is
        ///     set to use <see cref="CamelCasePropertyNamesContractResolver" />
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddCamelCaseResultsOptions(this IMvcCoreBuilder builder)
        {
            CamelCaseResultsCommon(builder.Services);

            return builder;
        }

        ///// <summary>
        /////     Adds the MVC consumes produces json resource result filters for application/json" and
        /////     "application/json-patch+json.  In addition will make sure that
        /////     <see cref="MvcJsonOptions.SerializerSettings" />.ContractResolver is
        /////     set to use <see cref="CamelCasePropertyNamesContractResolver" />
        /////     <para>
        /////         I should be called as early as possible in the configure services chain.
        /////     </para>
        ///// </summary>
        ///// <param name="builder">IMvcBuilder</param>
        ///// <returns>IMvcBuilder.</returns>
        //[Obsolete("Not strictly needed since 2.2, will be removed later.")]
        //public static IMvcBuilder AddConsumesProducesJsonResourceResultFilters(this IMvcBuilder builder)
        //{
        //    ConsumesProducesCommon(builder.Services);

        //    return builder;
        //}

        /// <summary>
        ///   Will make sure that
        ///     <see cref="MvcJsonOptions.SerializerSettings" />.ContractResolver is
        ///     set to use <see cref="CamelCasePropertyNamesContractResolver" />
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddCamelCaseResultsOptions(this IMvcBuilder builder)
        {
            CamelCaseResultsCommon(builder.Services);

            return builder;
        }

        /// <summary>
        ///     Adds an MVC convention that requires DI.
        /// </summary>
        /// <typeparam name="TConvention">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="setupAction"></param>
        /// <returns>IMvcCoreBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcCoreBuilder AddConvention<TConvention>(
            this IMvcCoreBuilder builder,
            Action<MvcOptions, TConvention> setupAction = null
        )
            where TConvention : class, IApplicationModelConvention
        {
            builder.Services.AddDependencyWithOptions(setupAction ?? ((o, c) => o.Conventions.TryAdd(c)));

            return builder;
        }

        /// <summary>
        ///     Adds an MVC convention that requires DI.
        /// </summary>
        /// <typeparam name="TConvention">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="setupAction"></param>
        /// <returns>IMvcBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcBuilder AddConvention<TConvention>(
            this IMvcBuilder builder,
            Action<MvcOptions, TConvention> setupAction = null
        )
            where TConvention : class, IApplicationModelConvention
        {
            builder.Services.AddDependencyWithOptions(setupAction ?? ((o, c) => o.Conventions.TryAdd(c)));

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a specific structure,
        ///     IE: {
        ///     data:{ value } | data:[{ value }],
        ///     pagination:{
        ///     totalCount:number,
        ///     nextPage:number,
        ///     previousPage:number
        ///     }
        ///     }
        ///     <para>Works independently of <see cref="EnsureResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="defaultPageSize">Default page size for pagination responses.</param>
        /// <param name="defineResponseFunc">Your user defined structure.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddEnsurePaginationResultActionFilter(
            this IMvcCoreBuilder builder,
            int defaultPageSize = 1000,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            PaginationCommon(builder.Services, defaultPageSize, defineResponseFunc);

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a specific structure,
        ///     IE: {
        ///     data:{ value } | data:[{ value }],
        ///     pagination:{
        ///     totalCount:number,
        ///     nextPage:number,
        ///     previousPage:number
        ///     }
        ///     }
        ///     <para>Works independently of <see cref="EnsureResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="defaultPageSize">Default page size for pagination responses.</param>
        /// <param name="defineResponseFunc">Your user defined structure.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddEnsurePaginationResultActionFilter(
            this IMvcBuilder builder,
            int defaultPageSize = 1000,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            PaginationCommon(builder.Services, defaultPageSize, defineResponseFunc);

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a structure, defined by you in the callback.
        ///     Defaults to: {
        ///     data:{ value } | data:[{ value }]
        ///     }
        ///     <para>Works independently of <see cref="EnsurePaginationResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="onlyQueryActions">When false, your structure will be applied to all http methods.</param>
        /// <param name="defineResponseFunc">Your user defined structure.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddEnsureResponseResultActionFilter(
            this IMvcCoreBuilder builder,
            bool onlyQueryActions = true,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            if (!(defineResponseFunc is null))
                InternalHelpers.EnsureResponseCompliesWithAction = defineResponseFunc;

            InternalHelpers.ApplyEnsureResponseCompliesWithQueryActionsOnly = onlyQueryActions;

            builder.Services.Configure<MvcOptions>(o =>
                {
                    FindExistingResultActionFilterAndThrow(o.Filters, nameof(EnsureResponseResultActionFilter));
                    o.Filters.TryAdd<EnsureResponseResultActionFilter>();
                }
            );

            return builder;
        }

        /// <summary>
        ///     This filter will ensure all results comply to a structure, defined by you in the callback.
        ///     Defaults to: {
        ///     data:{ value } | data:[{ value }]
        ///     }
        ///     <para>Works independently of <see cref="EnsurePaginationResponseResultActionFilter" /></para>
        ///     <para>This is only applied to actions that return <see cref="ObjectResult" /></para>
        /// </summary>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="onlyQueryActions">When false, your structure will be applied to all http methods.</param>
        /// <param name="defineResponseFunc">Your user defined structure.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddEnsureResponseResultActionFilter(
            this IMvcBuilder builder,
            bool onlyQueryActions = true,
            Func<object, dynamic> defineResponseFunc = null
        )
        {
            if (!(defineResponseFunc is null))
                InternalHelpers.EnsureResponseCompliesWithAction = defineResponseFunc;

            InternalHelpers.ApplyEnsureResponseCompliesWithQueryActionsOnly = onlyQueryActions;

            builder.Services.Configure<MvcOptions>(o =>
                {
                    FindExistingResultActionFilterAndThrow(o.Filters, nameof(EnsureResponseResultActionFilter));
                    o.Filters.TryAdd<EnsureResponseResultActionFilter>();
                }
            );

            return builder;
        }

        /// <summary>
        ///     Adds the e tag action filter.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddETagActionFilter(this IMvcCoreBuilder builder)
        {
            builder.AddFilter<ETagActionFilter>();

            return builder;
        }

        /// <summary>
        ///     Adds the e tag action filter.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddETagActionFilter(this IMvcBuilder builder)
        {
            builder.AddFilter<ETagActionFilter>();

            return builder;
        }

        /// <summary>
        ///     Adds an MVC filter with optional setup.  If setup is null, then
        ///     <see cref="APIBlox.AspNetCore.Extensions.CollectionExtensions.TryAdd{TType}(FilterCollection)" /> will be used.
        /// </summary>
        /// <typeparam name="TFilter">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="setupAction"></param>
        /// <returns>IMvcCoreBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcCoreBuilder AddFilter<TFilter>(
            this IMvcCoreBuilder builder,
            Action<MvcOptions> setupAction = null
        )
            where TFilter : class, IFilterMetadata
        {
            builder.Services.Configure(setupAction ?? (o => o.Filters.TryAdd<TFilter>()));

            return builder;
        }

        /// <summary>
        ///     Adds an MVC filter with optional setup.  If setup is null, then
        ///     <see cref="APIBlox.AspNetCore.Extensions.CollectionExtensions.TryAdd{TType}(FilterCollection)" /> will be used.
        /// </summary>
        /// <typeparam name="TFilter">The type of the t convention.</typeparam>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="setupAction"></param>
        /// <returns>IMvcBuilder.</returns>
        /// <autogeneratedoc />
        public static IMvcBuilder AddFilter<TFilter>(
            this IMvcBuilder builder,
            Action<MvcOptions> setupAction = null
        )
            where TFilter : class, IFilterMetadata
        {
            builder.Services.Configure(setupAction ?? (o => o.Filters.TryAdd<TFilter>()));

            return builder;
        }

        /// <summary>
        ///     This filter will prevent errors from being logged when actions have been cancelled.
        ///     If Exception is an OperationCanceledException it is handled otherwise disregarded.
        ///     <para>
        ///         Note that when using fiddler (or maybe other proxies) and when using IISExpress (at this time)
        ///         HttpContext.RequestAborted.IsCancellationRequested is ALWAYS false.
        ///         In other words, this filter won't do a damn thing.
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddOperationCancelledExceptionFilter(this IMvcCoreBuilder builder)
        {
            builder.AddFilter<OperationCanceledExceptionFilter>();

            return builder;
        }

        /// <summary>
        ///     This filter will prevent errors from being logged when actions have been cancelled.
        ///     If Exception is an OperationCanceledException it is handled otherwise disregarded.
        ///     <para>
        ///         Note that when using fiddler (or maybe other proxies) and when using IISExpress (at this time)
        ///         HttpContext.RequestAborted.IsCancellationRequested is ALWAYS false.
        ///         In other words, this filter won't do a damn thing.
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcBuilder</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddOperationCancelledExceptionFilter(this IMvcBuilder builder)
        {
            builder.AddFilter<OperationCanceledExceptionFilter>();

            return builder;
        }

        /// <summary>
        ///     Use with <see cref="PopulateAttribute" /> to bind route and query params data to the request objects private
        ///     properties.
        /// </summary>
        /// <param name="builder">The mvc core builder.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddPopulateRequestObjectActionFilter(this IMvcCoreBuilder builder)
        {
            builder.AddFilter<PopulateRequestObjectActionFilter>();

            return builder;
        }

        /// <summary>
        ///     Use with <see cref="PopulateAttribute" /> to bind route and query params data to the request objects private
        ///     properties.
        /// </summary>
        /// <param name="builder">The mvc builder.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddPopulateRequestObjectActionFilter(this IMvcBuilder builder)
        {
            builder.AddFilter<PopulateRequestObjectActionFilter>();

            return builder;
        }

        /// <summary>
        ///     I MUST be added  after any and all APIBlox features in the builder chain.
        ///     <para>
        ///         DID YOU READ THE ABOVE?!
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcCoreBuilder</param>
        /// <param name="configuration">The configuration.</param>
        /// <param name="env">The env.</param>
        /// <param name="configSection">Configuration section</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddRouteTokensConvention(
            this IMvcCoreBuilder builder,
            IConfiguration configuration, IHostingEnvironment env,
            string configSection = "RouteTokenOptions"
        )
        {
            builder.Services.Configure<MvcOptions>(o =>
                o.Conventions.Add(new RouteTokensConvention(CommonRouteTokens(configuration, env, configSection)))
            );

            return builder;
        }

        /// <summary>
        ///     I MUST be added  after any and all APIBlox features in the builder chain.
        ///     <para>
        ///         DID YOU READ THE ABOVE?!
        ///     </para>
        /// </summary>
        /// <param name="builder">IMvcBuilder</param>
        /// <param name="configuration">The configuration.</param>
        /// <param name="env">The env.</param>
        /// <param name="configSection">Configuration section in the form of string dictionary.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddRouteTokensConvention(
            this IMvcBuilder builder,
            IConfiguration configuration, IHostingEnvironment env,
            string configSection = "RouteTokenOptions"
        )
        {
            builder.Services.Configure<MvcOptions>(o =>
                o.Conventions.Add(new RouteTokensConvention(CommonRouteTokens(configuration, env, configSection)))
            );

            return builder;
        }

        /// <summary>
        ///     Adds RFC 7807 Problem Details for HTTP APIs support.  We are using our <see cref="ValidateResourceActionFilter" />
        ///     which in turn will generate a <see cref="ValidationFailureResult" />
        ///     <para>Note this requires that <see cref="ApiBehaviorOptions.SuppressModelStateInvalidFilter" /> be true.</para>
        /// </summary>
        /// <seealso cref="ValidateResourceActionFilter" />
        /// <param name="builder">IMvcCoreBuilder.</param>
        /// <returns>IMvcCoreBuilder.</returns>
        public static IMvcCoreBuilder AddValidateResourceActionFilter(this IMvcCoreBuilder builder)
        {
            builder.Services.Configure<ApiBehaviorOptions>(o =>
                {
                    o.SuppressUseValidationProblemDetailsForInvalidModelStateResponses = true;
                    o.SuppressModelStateInvalidFilter = true;
                }
            );

            return builder.AddFilter<ValidateResourceActionFilter>();
        }

        /// <summary>
        ///     Adds RFC 7807 Problem Details for HTTP APIs support.  We are using our <see cref="ValidateResourceActionFilter" />
        ///     which in turn will generate a <see cref="ValidationFailureResult" />
        ///     <para>Note this requires that <see cref="ApiBehaviorOptions.SuppressModelStateInvalidFilter" /> be true.</para>
        /// </summary>
        /// <seealso cref="ValidateResourceActionFilter" />
        /// <param name="builder">IMvcBuilder.</param>
        /// <returns>IMvcBuilder.</returns>
        public static IMvcBuilder AddValidateResourceActionFilter(this IMvcBuilder builder)
        {
            builder.Services.Configure<ApiBehaviorOptions>(o =>
                {
                    o.SuppressUseValidationProblemDetailsForInvalidModelStateResponses = true;
                    o.SuppressModelStateInvalidFilter = true;
                }
            );

            return builder.AddFilter<ValidateResourceActionFilter>();
        }

        private static void PaginationCommon(IServiceCollection services, int defaultPageSize = 100, Func<object, dynamic> defineResponseFunc = null)
        {
            if (!(defineResponseFunc is null))
                InternalHelpers.EnsureResponseCompliesWithAction = defineResponseFunc;

            services.AddTransient<IPaginationMetadataBuilder, PaginationMetadataBuilder>(s =>
                new PaginationMetadataBuilder(defaultPageSize)
            );

            services.Configure<MvcOptions>(o =>
                {
                    FindExistingResultActionFilterAndThrow(o.Filters,
                        nameof(EnsurePaginationResponseResultActionFilter)
                    );
                    o.Filters.TryAdd<EnsurePaginationResponseResultActionFilter>();
                }
            );
        }

        private static Dictionary<string, string> CommonRouteTokens(IConfiguration configuration, IHostingEnvironment env, string configSection)
        {
            var ret = configuration.GetSection(configSection).Get<Dictionary<string, string>>();

            if (ret is null)
                throw new ArgumentException(
                    $"In order to use the {nameof(RouteTokensConvention)} you " +
                    $"will need to have an {configSection} configuration entry with key value pairs."
                );

            var hasEnv = ret.ContainsKey("Environment")
                         || ret.ContainsKey("environment");

            if (!hasEnv)
                ret.Add("environment", env.EnvironmentName.ToCamelCase());

            return ret;
        }

        //private static void ConsumesProducesCommon(IServiceCollection services)
        //{
        //    services.Configure<MvcOptions>(o =>
        //        o.Filters.TryAdd(new ProducesAttribute("application/json"))
        //            .TryAdd(new ConsumesAttribute("application/json", "application/json-patch+json"))
        //    );
        //}

        private static void CamelCaseResultsCommon(IServiceCollection services)
        {
            services.Configure<MvcJsonOptions>(s =>
                {
                    if (!(s.SerializerSettings.ContractResolver is CamelCasePropertyNamesContractResolver))
                        s.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
                }
            );
        }

        private static void FindExistingResultActionFilterAndThrow(FilterCollection filters, string who)
        {
            foreach (var objFilter in filters)
            {
                if (!(objFilter is TypeFilterAttribute attr))
                    continue;

                if (!attr.ImplementationType.IsAssignableTo(typeof(EnsureResponseResultActionFilter)))
                    continue;

                throw new ArgumentException(
                    $"You have already added an {attr.ImplementationType.Name}, " +
                    $"the {who} can not be used."
                );
            }
        }
    }
}
